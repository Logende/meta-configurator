The architecture of \toolname{}, as discussed and implemented in \cite{metaconfigurator} offers enough modularity to support different data formats and implement different \textit{panels}, such as the \textit{text editor panel} or the \textit{GUI editor panel}. 
However, it also is lacking in multiple aspects.
In this section, those limitations are addressed and architectural improvements suggested and implemented.

\subsubsection{Managing multiple schemas and data files simultaneously}
The original design features a single source of truth store, which is responsible for the currently loaded schema and \cfgfile{}. 
There can only be one schema and \cfgfile{} loaded at any given time.
When the user changes the tool \textit{mode} $\in$ \{\textit{File editor}, \textit{Schema editor}, \textit{Settings}\}, the schema and \cfgfile{} in the store are replaced accordingly.
Table \ref{tab:schema_and_file_data_by_mode} illustrates which file data and schema are used for the different modes.
Due to that design decision, within all subcomponents of the tool, the central store can be accessed directly, instead of having to pass the current schema and file through the complete component hierarchy. 
This comes with one major drawback: it is not possible to have the schema and data of different views loaded at the same time.
However, being able to simultaneously show content of different modes could significantly help the user.
For example, in the schema editor view, the file editor GUI could be shown too, giving the user a preview of the GUI that their schema will result in.
\begin{table}[!t]
\caption{File data and schema for the different modes}
\label{tab:schema_and_file_data_by_mode}
\centering
\begin{tabular}{lll}
\toprule
\textbf{Mode} & \textbf{Effective File Data} & \textbf{Effective Schema} \\
\midrule
File editor   & User data                    & User schema               \\
Schema editor & User schema                  & JSON Schema Meta Schema          \\
Settings      & Settings data                & Settings schema           \\
\bottomrule
\end{tabular}
\end{table}

To get rid of this limitation, we remove the $sessionStore = \{currentSchema, currentFileData, ...\}$.
Instead, we create a new store, which for each \textit{mode} stores the corresponding \textit{schema}, \textit{file data}, \textit{user selections} (e.g., which path is currently selected and which properties in the tree are expanded) and \textit{validation results}.
Additionally, we introduce mapping functions (e.g., $getDataForMode: mode \rightarrow {fileData}$), with which the content can be accessed.
Instead of the subcomponents of \toolname{} always accessing the one current schema and file data, they now each receive a \textit{mode} in their constructor and access the corresponding data.
For example, we can instantiate a text editor panel with the mode \textit{file editor}.
This panel will now use schema and data of the \textit{file editor} mode.
This architecture allows us to arrange panels of different types and different modes in an arbitrary manner, which brings us to our next point.



\subsubsection{Dynamic panel arrangement}
TODO




\subsubsection{Decoupling}
Having a single source of truth store that can be accessed from anywhere can be tempting.
However, a component that uses the store depends on the store too.
Sometimes, this dependency is not required and not even desired either.
For example, the JSON schema preprocessing function is called with a JSON schema or sub-schema that is supposed to be preprocessed (e.g., references are resolved in a lazy manner).
For reference resolving, the function requires all definitions of the properties to be resolved. 
When only a sub-schema is provided to the function (this is the case when an object is expanded in the GUI editor), this sub-schema does usually not contain the definitions of the referenced data structures.
To deal with this, \toolname{} accesses the store to receive the current schema, based on which it resolves the references.
This, however, introduces the limitation that the function can only preprocess schemas which are currently loaded in the store and assigned to one of the modes.
We decouple the function from the store, by introducing a second function parameter \textit{rootSchema}, which expects the root schema to use. 
As a result, the function can take in any sub-schema and root schema, regardless of whether they are loaded in the store or not.

% TODO: not true, it is actually not implemented yet