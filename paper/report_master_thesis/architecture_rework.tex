The architecture of \toolname{}, as discussed and implemented in \cite{metaconfigurator} offers enough modularity to support different data formats and implement different \textit{panels}, such as the \textit{text editor panel} or the \textit{GUI editor panel}. 
However, it also is lacking in multiple aspects.
In this section, those limitations are addressed and architectural improvements suggested and implemented.

\subsubsection{Managing multiple schemas and data files simultaneously}
The original design features a single source of truth store, which is responsible for the currently loaded schema and \cfgfile{}. 
There can only be one schema and \cfgfile{} loaded at any given time.
When the user changes the tool \textit{mode} $\in$ \{\textit{File editor}, \textit{Schema editor}, \textit{Settings}\}, the schema and \cfgfile{} in the store are replaced accordingly.
Table \ref{tab:schema_and_file_data_by_mode} illustrates which file data and schema are used for the different modes.
Therefore, within most subcomponents of the tool, the central store is accessed directly, instead of passing the current schema and file through the component hierarchy. 
This comes with one major drawback: it is not possible to have the schema and data of different views loaded at the same time.
However, being able to simultaneously show content of different modes could significantly help the user.
For example, in the schema editor view, the file editor GUI could be shown too, giving the user a preview of the GUI that their schema will result in.
\begin{table}[!t]
\caption{File data and schema for the different modes}
\label{tab:schema_and_file_data_by_mode}
\centering
\begin{tabular}{lll}
\toprule
\textbf{Mode} & \textbf{Effective File Data} & \textbf{Effective Schema} \\
\midrule
File editor   & User data                    & User schema               \\
Schema editor & User schema                  & JSON Schema Meta Schema          \\
Settings      & Settings data                & Settings schema           \\
\bottomrule
\end{tabular}
\end{table}

To get rid of this limitation, we remove the $sessionStore = \{currentSchema, currentFileData, ...\}$.
Instead, we create a new store, which for each \textit{mode} stores the corresponding \textit{schema}, \textit{file data}, \textit{user selections} (e.g., which path is currently selected and which properties in the tree are expanded) and \textit{validation results}.
Additionally, we introduce mapping functions (e.g., $getDataForMode: mode \rightarrow {fileData}$), with which the content can be accessed.
Instead of the subcomponents of \toolname{} always accessing the one current schema and file data, they now each receive a \textit{mode} in their constructor and access the corresponding data.
For example, we can instantiate a text editor panel with the mode \textit{file editor}.
This panel will now use schema and data of the \textit{file editor} mode.
This architecture allows us to arrange panels of different types and different modes in an arbitrary manner, which brings us to our next point.



\subsubsection{Dynamic panel arrangement}
The \textit{GUI editor} (todo: reference) or \textit{file editor} (todo: reference) are what we call \textit{panels}.
They have access to the \textit{schema} and \textit{file data} and visualize them in a particular manner.
They can also update the \textit{file data} or the \textit{currently selected element}, which are synchronized across all panels.
\toolname{} can be extended by more panels.
Table \ref{tab:panels_by_mode} shows which panels are used for the different tool modes, and their assigned panel modes (which data and schema to use).
As a result, for every mode, \toolname{} provides a text editor panel and a GUI editor panel, both using the data and schema of the corresponding mode.

\begin{table}[!t]
\caption{Panels and their data sources for the different modes}
\label{tab:panels_by_mode}
\centering\scriptsize
\begin{tabular}{@{}lll@{}}
\toprule
\textbf{Tool Mode} & \textbf{Panel 1: type(mode)} & \textbf{Panel 2: type(mode)} \\ \midrule
File editor        & Text editor(file editor)     & GUI editor(file editor)      \\
Schema editor      & Text editor(schema editor)   & GUI editor(schema editor)    \\
Settings           & Text editor(settings)        & GUI editor(settings)         \\ \bottomrule
\end{tabular}
\end{table}

To allow for more variation in the panels configuration (arrangement), we turn it into a setting.
This setting can be adjusted by the user (see figure \ref{fig:panels_definition_file_editor}) or by \toolname{} itself.
Table \ref{tab:panels_by_mode_schema_editor_with_preview} shows an alternative configuration for the panels of the schema editor.
It contains an additional GUI editor panel, which uses the data and schema from file editor mode. 
This configuration results in a schema editor, where the user gets a (functional) preview of the GUI that their schema will generate, see figure \ref{fig:panels_for_modified_schema_editor_config}.



\begin{figure}[!t]
    \centering
    \includegraphics[width=\columnwidth]{figures/panels_definition_file_editor}
    \caption{Settings GUI editor view with panels configuration for \textit{file editor} mode}
    \label{fig:panels_definition_file_editor}
\end{figure}


\begin{table}[!t]
\caption{Modified schema editor panel configuration}
\label{tab:panels_by_mode_schema_editor_with_preview}
\centering\tiny
\begin{tabular}{@{}llll@{}}
\toprule
\textbf{Tool Mode} & \textbf{Panel 1: type(mode)} & \textbf{Panel 2: type(mode)}& \textbf{Panel 3: type(mode)} \\ \midrule
Schema editor      & Text editor(schema editor)   & GUI editor(schema editor)   & GUI editor(file editor)    
  \\ \bottomrule
\end{tabular}
\end{table}


\begin{figure*}
    \includegraphics[width=\textwidth]{figures/panels_for_modified_schema_editor_config}
    \caption{Schema editor with a preview of the resulting GUI on the right}
    \label{fig:panels_for_modified_schema_editor_config}
\end{figure*}



\subsubsection{Decoupling}
Having a single source of truth store that can be accessed from anywhere can be tempting.
However, a component that uses the store depends on the store too.
Sometimes, this dependency is not required and not even desired either.
For example, the JSON schema preprocessing function is called with a JSON schema or sub-schema that is supposed to be preprocessed (e.g., references are resolved in a lazy manner).
For reference resolving, the function requires all definitions of the properties to be resolved. 
When only a sub-schema is provided to the function (this is the case when an object is expanded in the GUI editor), this sub-schema does usually not contain the definitions of the referenced data structures.
To deal with this, \toolname{} accesses the store to receive the current schema, based on which it resolves the references.
This, however, introduces the limitation that the function can only preprocess schemas which are currently loaded in the store and assigned to one of the modes.
We decouple the function from the store, by introducing a second function parameter \textit{rootSchema}, which expects the root schema to use. 
As a result, the function can take in any sub-schema and root schema, regardless of whether they are loaded in the store or not.

% TODO: not true, it is actually not implemented yet